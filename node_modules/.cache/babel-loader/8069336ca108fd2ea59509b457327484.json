{"ast":null,"code":"var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport cloneDeep from 'lodash/cloneDeep';\nimport DualListArrows from './components/DualListArrows';\nimport DualListSelector from './components/DualListSelector';\nimport DualListHiddenSelect from './components/DualListHiddenSelect';\nimport { noop, debounce } from '../../common/helpers';\nimport { arrangeArray, isAllChildrenChecked, reverseAllItemsOrder, getItem, getUpdatedSelectCount, itemHasParent, itemHasChildren, toggleAllItems, isAllItemsChecked, isItemExistOnList, filterByHiding, getFilterredItemsLength, makeAllItemsVisible, getSelectedFilterredItemsLength, isItemSelected, getFilterredItems } from './helpers';\n\nvar DualList = function (_React$Component) {\n  _inherits(DualList, _React$Component);\n\n  function DualList(props) {\n    _classCallCheck(this, DualList);\n\n    var _this = _possibleConstructorReturn(this, (DualList.__proto__ || Object.getPrototypeOf(DualList)).call(this, props));\n\n    _this.onItemChange = function (_ref) {\n      var _ref$target = _ref.target,\n          checked = _ref$target.checked,\n          _ref$target$dataset = _ref$target.dataset,\n          position = _ref$target$dataset.position,\n          side = _ref$target$dataset.side,\n          parentPosition = _ref$target$dataset.parentPosition;\n      var _this$props$side = _this.props[side],\n          originalSelectCount = _this$props$side.selectCount,\n          originalItems = _this$props$side.items,\n          isSortAsc = _this$props$side.isSortAsc,\n          filterTerm = _this$props$side.filterTerm;\n      var items = cloneDeep(originalItems);\n      var item = getItem(isSortAsc, items, position, parentPosition);\n      var selectCount = originalSelectCount;\n      item.checked = checked;\n\n      if (itemHasParent(item)) {\n        var parent = getItem(isSortAsc, items, parentPosition);\n        parent.checked = isAllChildrenChecked(parent);\n        selectCount = getUpdatedSelectCount(selectCount, checked);\n      } else if (itemHasChildren(item)) {\n        var children = item.children;\n        toggleAllItems(children, checked);\n        selectCount = getUpdatedSelectCount(selectCount, checked, children.length);\n      } else {\n        selectCount = getUpdatedSelectCount(selectCount, checked);\n      }\n\n      var isMainChecked = false;\n\n      if (filterTerm) {\n        var filteredItemsLength = getFilterredItemsLength(items);\n        var selectedFilteredItemsLength = getSelectedFilterredItemsLength(items);\n        isMainChecked = filteredItemsLength > 0 && selectedFilteredItemsLength === filteredItemsLength;\n      } else {\n        isMainChecked = isAllItemsChecked(items, selectCount);\n      }\n\n      _this.props.onItemChange({\n        side: side,\n        items: items,\n        selectCount: selectCount,\n        isMainChecked: isMainChecked\n      });\n    };\n\n    _this.onMainCheckboxChange = function (_ref2) {\n      var _ref2$target = _ref2.target,\n          checked = _ref2$target.checked,\n          side = _ref2$target.dataset.side;\n      var _this$props$side2 = _this.props[side],\n          originalItems = _this$props$side2.items,\n          filterTerm = _this$props$side2.filterTerm,\n          originalSelectCount = _this$props$side2.selectCount;\n      var items = cloneDeep(originalItems);\n      var selectCount = originalSelectCount;\n\n      if (filterTerm) {\n        var filterredItems = getFilterredItems(items);\n        var toggledAmount = toggleAllItems(filterredItems, checked);\n        selectCount += toggledAmount * (checked ? 1 : -1);\n      } else {\n        var _toggledAmount = toggleAllItems(items, checked);\n\n        selectCount = checked ? selectCount + _toggledAmount : 0;\n      }\n\n      _this.props.onMainCheckboxChange({\n        side: side,\n        checked: checked,\n        items: items,\n        selectCount: selectCount\n      });\n    };\n\n    _this.onSortClick = function (_ref3) {\n      var side = _ref3.target.dataset.side;\n      var _this$props$side3 = _this.props[side],\n          items = _this$props$side3.items,\n          isSortAsc = _this$props$side3.isSortAsc;\n      var itemsReversed = reverseAllItemsOrder(items);\n\n      _this.props.onSortClick({\n        side: side,\n        items: itemsReversed,\n        isSortAsc: !isSortAsc\n      });\n    };\n\n    _this.onFilterChange = function (event) {\n      /** https://reactjs.org/docs/events.html#event-pooling */\n      event.persist();\n\n      _this.onFilterChangeDebounced(event);\n    };\n\n    _this.emitFilterChange = function (_ref4) {\n      var _ref4$target = _ref4.target,\n          value = _ref4$target.value,\n          side = _ref4$target.dataset.side;\n      var _this$props$side4 = _this.props[side],\n          originalItems = _this$props$side4.items,\n          selectCount = _this$props$side4.selectCount;\n      var filterTerm = value.trim();\n\n      if (!value) {\n        var _items = makeAllItemsVisible(originalItems);\n\n        var _isMainChecked = isAllItemsChecked(_items, selectCount);\n\n        _this.props.onFilterChange({\n          side: side,\n          filterTerm: filterTerm,\n          items: _items,\n          isMainChecked: _isMainChecked\n        });\n\n        return;\n      }\n\n      var items = filterByHiding(originalItems, filterTerm);\n      var filteredItemsLength = getFilterredItemsLength(items);\n      var isMainChecked = filteredItemsLength > 0 && getSelectedFilterredItemsLength(items) === filteredItemsLength;\n\n      _this.props.onFilterChange({\n        side: side,\n        filterTerm: filterTerm,\n        items: items,\n        isMainChecked: isMainChecked\n      });\n    };\n\n    _this.moveTo = function (otherSide) {\n      var _this$props$onChange;\n\n      var side = otherSide === 'right' ? 'left' : 'right';\n      var sideState = _this.props[side];\n      var otherSideState = _this.props[otherSide];\n      var sideItemsWithRemainChildren = [];\n      var otherSideItems = cloneDeep(otherSideState.items);\n      var sideItems = sideState.items.filter(function (item) {\n        if (isItemSelected(item)) {\n          if (itemHasChildren(item)) {\n            var _isItemExistOnList = isItemExistOnList(otherSideItems, item.label),\n                isParentExist = _isItemExistOnList.isParentExist,\n                parentIndex = _isItemExistOnList.parentIndex;\n\n            if (isParentExist) {\n              var children = otherSideItems[parentIndex].children;\n              children.push.apply(children, _toConsumableArray(item.children));\n              return false;\n            }\n          }\n\n          otherSideItems.push(item);\n          return false;\n        } else if (itemHasChildren(item)) {\n          var selectedChildren = [];\n          var unselectedChildren = [];\n          item.children.forEach(function (childItem) {\n            if (isItemSelected(childItem)) {\n              selectedChildren.push(childItem);\n            } else {\n              unselectedChildren.push(childItem);\n            }\n          });\n\n          if (selectedChildren.length > 0) {\n            var _isItemExistOnList2 = isItemExistOnList(otherSideItems, item.label),\n                _isParentExist = _isItemExistOnList2.isParentExist,\n                _parentIndex = _isItemExistOnList2.parentIndex;\n\n            if (_isParentExist) {\n              var _otherSideItems$_pare;\n\n              (_otherSideItems$_pare = otherSideItems[_parentIndex].children).push.apply(_otherSideItems$_pare, selectedChildren);\n            } else {\n              otherSideItems.push(_extends({}, item, {\n                checked: true,\n                children: selectedChildren\n              }));\n            }\n\n            if (unselectedChildren.length > 0) {\n              sideItemsWithRemainChildren.push(_extends({}, item, {\n                children: unselectedChildren\n              }));\n            }\n\n            return false;\n          }\n        }\n\n        return true;\n      });\n\n      if (sideItemsWithRemainChildren.length > 0) {\n        var _sideItems;\n\n        (_sideItems = sideItems).push.apply(_sideItems, sideItemsWithRemainChildren);\n      }\n\n      var updatedSideState = _extends({}, sideState, {\n        selectCount: 0,\n        isMainChecked: false\n      });\n\n      var updatedOtherSideState = _extends({}, otherSideState, {\n        selectCount: 0,\n        isMainChecked: false\n      });\n\n      sideItems = arrangeArray(_extends({}, updatedSideState, {\n        items: sideItems\n      }));\n      otherSideItems = arrangeArray(_extends({}, updatedOtherSideState, {\n        items: otherSideItems,\n        resetAllSelected: true\n      }));\n\n      _this.props.onChange((_this$props$onChange = {}, _defineProperty(_this$props$onChange, side, _extends({}, updatedSideState, {\n        items: sideItems\n      })), _defineProperty(_this$props$onChange, otherSide, _extends({}, updatedOtherSideState, {\n        items: otherSideItems\n      })), _this$props$onChange));\n    };\n\n    _this.leftArrowClick = function () {\n      var left = _this.props.arrows.left;\n      left.onClick();\n\n      _this.moveTo('left');\n    };\n\n    _this.rightArrowClick = function () {\n      var right = _this.props.arrows.right;\n      right.onClick();\n\n      _this.moveTo('right');\n    };\n\n    _this.onFilterChangeDebounced = debounce(_this.emitFilterChange, 200);\n    return _this;\n  }\n\n  _createClass(DualList, [{\n    key: 'render',\n    value: function render() {\n      var _props = this.props,\n          left = _props.left,\n          right = _props.right,\n          arrows = _props.arrows,\n          allowHiddenInputs = _props.allowHiddenInputs;\n      var hiddenInputs = allowHiddenInputs ? React.createElement(React.Fragment, null, React.createElement(DualListHiddenSelect, _extends({}, left.inputProps, {\n        items: left.items\n      })), React.createElement(DualListHiddenSelect, _extends({}, right.inputProps, {\n        items: right.items\n      }))) : null;\n      return React.createElement('div', {\n        className: 'dual-list-pf'\n      }, hiddenInputs, React.createElement(DualListSelector, _extends({\n        side: 'left'\n      }, left, {\n        onItemChange: this.onItemChange,\n        onSortClick: this.onSortClick,\n        onFilterChange: this.onFilterChange,\n        onMainCheckboxChange: this.onMainCheckboxChange\n      })), React.createElement(DualListArrows, {\n        left: {\n          onClick: this.leftArrowClick,\n          ariaLabel: arrows.left.ariaLabel\n        },\n        right: {\n          onClick: this.rightArrowClick,\n          ariaLabel: arrows.right.ariaLabel\n        }\n      }), React.createElement(DualListSelector, _extends({\n        side: 'right'\n      }, right, {\n        onItemChange: this.onItemChange,\n        onSortClick: this.onSortClick,\n        onFilterChange: this.onFilterChange,\n        onMainCheckboxChange: this.onMainCheckboxChange\n      })));\n    }\n  }]);\n\n  return DualList;\n}(React.Component);\n\nDualList.propTypes = {\n  /**\n   * - items: Array of objects that must contain a label and a value.\n   * - options: The Kebab menu items.\n   * - isSortAsc: Set the list items sorting direction.\n   * - sortBy: set the list items sorting factor.\n   * - isMainChecked: Set the main checkbox state.\n   */\n  left: PropTypes.shape({\n    items: PropTypes.arrayOf(PropTypes.shape({\n      label: PropTypes.string.isRequired,\n      value: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).isRequired,\n      children: PropTypes.arrayOf(PropTypes.shape({\n        label: PropTypes.string,\n        value: PropTypes.oneOfType([PropTypes.number, PropTypes.string])\n      }))\n    })),\n    options: PropTypes.node,\n    isSortAsc: PropTypes.bool,\n    sortBy: PropTypes.string,\n    isMainChecked: PropTypes.bool,\n    inputProps: PropTypes.object\n  }),\n\n  /**\n   * - items: Array of objects that must contain a label and a value.\n   * - options: The Kebab menu items.\n   * - isSortAsc: Set the list items sorting direction.\n   * - isMainChecked: Set the main checkbox state.\n   * - sortBy: set the list items sorting factor.\n   */\n  right: PropTypes.shape({\n    items: PropTypes.arrayOf(PropTypes.shape({\n      label: PropTypes.string,\n      value: PropTypes.oneOfType([PropTypes.number, PropTypes.string])\n    })),\n    options: PropTypes.node,\n    isSortAsc: PropTypes.bool,\n    sortBy: PropTypes.string,\n    isMainChecked: PropTypes.bool,\n    inputProps: PropTypes.object\n  }),\n\n  /**\n   * - Conatains the left and right arrows properties,\n   * - Where in every object there are:\n   * - onClick - function which determine the onClick event,\n   * - ariaLabel - set the aria-label text.\n   */\n  arrows: PropTypes.shape({\n    left: PropTypes.shape({\n      onClick: PropTypes.func,\n      ariaLabel: PropTypes.string\n    }),\n    right: PropTypes.shape({\n      onClick: PropTypes.func,\n      ariaLabel: PropTypes.string\n    })\n  }),\n\n  /**\n   * Allows adding hidden select inputs\n   * that reflects the dual list selected items.\n   * It can be used while submitting a form to access the dual list data.\n   * */\n  allowHiddenInputs: PropTypes.bool,\n\n  /**\n   * Function that runs after an item was clicked.\n   * receives an object of: { side, items, selectCount, isMainChecked } as a callback.\n   */\n  onItemChange: PropTypes.func,\n\n  /**\n   * Function that runs after the sort icon was clicked.\n   * receives an object of: { side, items, isSortAsc } as a callback.\n   */\n  onSortClick: PropTypes.func,\n\n  /**\n   * Function that runs after the filter input has changed.\n   * receives an object of: { side, filterTerm } as a callback.\n   */\n  onFilterChange: PropTypes.func,\n\n  /**\n   * Function that runs after the main checkbox was clicked.\n   * receives an object of: { side, checked, items, selectCount } as a callback.\n   */\n  onMainCheckboxChange: PropTypes.func,\n\n  /**\n   * Function that runs after items have been moved between the lists.\n   * receives an object of: { left, right } updated sides as a callback.\n   */\n  onChange: PropTypes.func\n};\nDualList.defaultProps = {\n  left: {\n    items: [],\n    options: null,\n    isSortAsc: true,\n    sortBy: 'label',\n    filterTerm: '',\n    isMainChecked: false,\n    inputProps: null\n  },\n  right: {\n    items: [],\n    options: null,\n    isSortAsc: true,\n    sortBy: 'label',\n    filterTerm: '',\n    isMainChecked: false,\n    inputProps: null\n  },\n  arrows: {\n    left: {\n      onClick: noop,\n      ariaLabel: null\n    },\n    right: {\n      onClick: noop,\n      ariaLabel: null\n    }\n  },\n  allowHiddenInputs: false,\n  onItemChange: noop,\n  onSortClick: noop,\n  onFilterChange: noop,\n  onMainCheckboxChange: noop,\n  onChange: noop\n};\nexport default DualList;","map":null,"metadata":{},"sourceType":"module"}