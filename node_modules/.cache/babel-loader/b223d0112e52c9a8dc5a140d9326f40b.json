{"ast":null,"code":"var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport { getContext } from 'recompose';\nimport { ListGroup, ListGroupItem } from '../ListGroup';\nimport { OverlayTrigger } from '../OverlayTrigger';\nimport { Tooltip } from '../Tooltip';\nimport VerticalNavBadge from './VerticalNavBadge';\nimport { filterChildren, hasDisplayName } from '../../common/helpers';\nimport VerticalNavDividerItem from './VerticalNavDividerItem';\nimport { NavContextProvider, getNextDepth, componentForDepth, isNavItem, getItemProps, itemObjectTypes, navContextTypes } from './VerticalNavConstants';\n\nvar BaseVerticalNavItemHelper = function (_React$Component) {\n  _inherits(BaseVerticalNavItemHelper, _React$Component);\n\n  function BaseVerticalNavItemHelper() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, BaseVerticalNavItemHelper);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = BaseVerticalNavItemHelper.__proto__ || Object.getPrototypeOf(BaseVerticalNavItemHelper)).call.apply(_ref, [this].concat(args))), _this), _this.onItemBlur = function (noDelay) {\n      var _this$getContextNavIt = _this.getContextNavItems(),\n          primary = _this$getContextNavIt.primary,\n          secondary = _this$getContextNavIt.secondary,\n          tertiary = _this$getContextNavIt.tertiary;\n\n      var _this$props = _this.props,\n          updateNavOnItemBlur = _this$props.updateNavOnItemBlur,\n          idPath = _this$props.idPath,\n          onBlur = _this$props.onBlur;\n      updateNavOnItemBlur(primary, secondary, tertiary, _this.idPath(), idPath, noDelay, onBlur);\n    }, _this.onItemClick = function (event) {\n      var _this$getContextNavIt2 = _this.getContextNavItems(),\n          primary = _this$getContextNavIt2.primary,\n          secondary = _this$getContextNavIt2.secondary,\n          tertiary = _this$getContextNavIt2.tertiary;\n\n      var _this$props2 = _this.props,\n          isMobile = _this$props2.isMobile,\n          preventHref = _this$props2.preventHref,\n          updateNavOnItemClick = _this$props2.updateNavOnItemClick,\n          idPath = _this$props2.idPath;\n\n      var _this$navItem = _this.navItem(),\n          onClick = _this$navItem.onClick;\n\n      if (preventHref && !!onClick) {\n        event.preventDefault();\n      }\n\n      updateNavOnItemClick(primary, secondary, tertiary, _this.idPath(), idPath); // Clears all mobile selections\n\n      if (isMobile) {\n        _this.onMobileSelection(primary, secondary, tertiary); // Applies new mobile selection here\n\n      }\n\n      _this.setActive();\n\n      onClick && onClick(primary, secondary, tertiary);\n    }, _this.onItemHover = function () {\n      var _this$getContextNavIt3 = _this.getContextNavItems(),\n          primary = _this$getContextNavIt3.primary,\n          secondary = _this$getContextNavIt3.secondary,\n          tertiary = _this$getContextNavIt3.tertiary;\n\n      var _this$props3 = _this.props,\n          updateNavOnItemHover = _this$props3.updateNavOnItemHover,\n          idPath = _this$props3.idPath,\n          onHover = _this$props3.onHover;\n      updateNavOnItemHover(primary, secondary, tertiary, _this.idPath(), idPath, onHover);\n    }, _this.onMobileSelection = function (primary, secondary, tertiary) {\n      var _this$props4 = _this.props,\n          setMobilePath = _this$props4.setMobilePath,\n          updateNavOnMobileSelection = _this$props4.updateNavOnMobileSelection;\n      setMobilePath(_this.idPath());\n      updateNavOnMobileSelection(primary, secondary, tertiary);\n    }, _this.getContextNavItems = function () {\n      // We have primary, secondary, and tertiary items as props if they are part of the parent context,\n      // but we also want to include the current item when calling handlers.\n      var _this$props5 = _this.props,\n          depth = _this$props5.depth,\n          primaryItem = _this$props5.primaryItem,\n          secondaryItem = _this$props5.secondaryItem,\n          tertiaryItem = _this$props5.tertiaryItem;\n\n      var navItem = _this.navItem();\n\n      return {\n        primary: depth === 'primary' ? navItem : primaryItem,\n        secondary: depth === 'secondary' ? navItem : secondaryItem,\n        tertiary: depth === 'tertiary' ? navItem : tertiaryItem\n      };\n    }, _this.setActive = function () {\n      _this.props.setActivePath(_this.idPath());\n    }, _this.id = function () {\n      var _this$navItem2 = _this.navItem(null, true),\n          id = _this$navItem2.id,\n          title = _this$navItem2.title; // Need to ignorePath here so we don't get an infinite call stack...\n\n\n      return id || title || _this.props.index;\n    }, _this.idPath = function () {\n      return '' + _this.props.idPath + _this.id() + '/';\n    }, _this.navItem = function (oldProps, ignorePath) {\n      var props = oldProps || _this.props; // Properties of the item object take priority over individual item props\n\n      var item = _extends({}, getItemProps(props), props.item); // Automatically set the active, hovered, and selectedOnMobile properties based on current path...\n      // ...But don't call idPath() when called from inside id(), or there will be an infinite loop.\n\n\n      var valOrOnPath = function valOrOnPath(val, path) {\n        return val || (ignorePath ? null : path && path.startsWith(_this.idPath()));\n      };\n\n      return _extends({}, item, {\n        active: valOrOnPath(item.active, props.activePath),\n        hovered: valOrOnPath(item.hovered, props.hoverPath),\n        selectedOnMobile: valOrOnPath(item.selectedOnMobile, props.mobilePath),\n        pinned: valOrOnPath(item.pinned, props.pinnedPath)\n      });\n    }, _this.pinNextDepth = function () {\n      var _this$props6 = _this.props,\n          isMobile = _this$props6.isMobile,\n          depth = _this$props6.depth,\n          setMobilePath = _this$props6.setMobilePath,\n          forceHideSecondaryMenu = _this$props6.forceHideSecondaryMenu,\n          setPinnedPath = _this$props6.setPinnedPath,\n          updateNavOnPin = _this$props6.updateNavOnPin,\n          idPath = _this$props6.idPath,\n          pinnedPath = _this$props6.pinnedPath;\n      var nextDepth = getNextDepth(depth);\n\n      if (isMobile) {\n        // On mobile, the pin buttons act as back buttons instead.\n        if (depth === 'primary') {\n          // Going back to primary nav clears all selection.\n          setMobilePath(null);\n        } else if (depth === 'secondary') {\n          // Going back to secondary nav de-selects this item and re-selects the parent.\n          setMobilePath(idPath); // idPath prop, which is parent's path, not this.idPath().\n        }\n      } else {\n        setPinnedPath(!pinnedPath ? _this.idPath() : null);\n\n        if (pinnedPath) {\n          forceHideSecondaryMenu();\n\n          _this.onItemBlur(true);\n        }\n      }\n\n      updateNavOnPin(_this.navItem(), nextDepth, !pinnedPath);\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  _createClass(BaseVerticalNavItemHelper, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      if (this.props.active) {\n        this.props.setControlledActivePath(true);\n      }\n\n      if (this.props.hovered) {\n        this.props.setControlledHoverPath(true);\n      }\n\n      if (this.props.selectedOnMobile) {\n        this.props.setControlledMobilePath(true);\n      }\n\n      if (this.props.pinned) {\n        this.props.setControlledPinnedPath(true);\n      }\n\n      if (this.navItem().initialActive) {\n        this.setActive();\n      }\n    }\n  }, {\n    key: 'componentWillReceiveProps',\n    value: function componentWillReceiveProps(newProps) {\n      var _props = this.props,\n          setControlledActivePath = _props.setControlledActivePath,\n          setControlledHoverPath = _props.setControlledHoverPath,\n          setControlledMobilePath = _props.setControlledMobilePath,\n          setControlledPinnedPath = _props.setControlledPinnedPath;\n\n      if (!this.props.active && newProps.active) {\n        // If the active prop is being added, make sure the activePath is in sync.\n        if (newProps.activePath !== this.idPath()) {\n          this.setActive();\n        }\n\n        setControlledActivePath(true);\n      }\n\n      if (!this.props.hovered && newProps.hovered) {\n        // If the hovered prop is being added, make sure the hoverPath is in sync.\n        if (newProps.hoverPath !== this.idPath()) {\n          this.setHovered();\n        }\n\n        setControlledHoverPath(true);\n      }\n\n      if (!this.props.selectedOnMobile && newProps.selectedOnMobile) {\n        // If the selectedOnMobile prop is being added, make sure the mobilePath is in sync.\n        if (newProps.mobilePath !== this.idPath()) {\n          this.setMobilePath(this.idPath());\n        }\n\n        setControlledMobilePath(true);\n      }\n\n      if (!this.props.pinned && newProps.pinned) {\n        // If the pinned prop is being added, make sure the pinnedPath is in sync.\n        if (newProps.pinnedPath !== this.idPath()) {\n          this.setPinnedPath(this.idPath());\n        }\n\n        setControlledPinnedPath(true);\n      }\n    }\n  }, {\n    key: 'setHovered',\n    value: function setHovered() {\n      this.props.setHoverPath(this.idPath());\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _classNames,\n          _this2 = this;\n\n      var _props2 = this.props,\n          pinnableMenus = _props2.pinnableMenus,\n          hiddenIcons = _props2.hiddenIcons,\n          isDivider = _props2.isDivider,\n          navCollapsed = _props2.navCollapsed,\n          showMobileSecondary = _props2.showMobileSecondary,\n          showMobileTertiary = _props2.showMobileTertiary,\n          showBadges = _props2.showBadges,\n          children = _props2.children,\n          isMobile = _props2.isMobile,\n          pinnedPath = _props2.pinnedPath,\n          id = _props2.id,\n          dataID = _props2.dataID; // The nav item can either be passed directly as one item object prop, or as individual props.\n\n      var navItem = this.navItem();\n      var active = navItem.active,\n          hovered = navItem.hovered,\n          selectedOnMobile = navItem.selectedOnMobile,\n          pinned = navItem.pinned,\n          title = navItem.title,\n          iconClass = navItem.iconClass,\n          badges = navItem.badges,\n          subItems = navItem.subItems,\n          href = navItem.href,\n          onClick = navItem.onClick,\n          className = navItem.className;\n      var depth = this.props.depth || 'primary';\n      var nextDepth = getNextDepth(depth);\n      var NextDepthItem = componentForDepth(nextDepth);\n      var childItemComponents = filterChildren(children, isNavItem) || subItems && subItems.length > 0 && subItems.map(function (childItem) {\n        return React.createElement(NextDepthItem, {\n          item: childItem,\n          key: childItem.title\n        });\n      });\n\n      if (!childItemComponents && !href && !onClick) {\n        // eslint-disable-next-line\n        console.warn('Warning: Non-navigable item at', this.idPath(), '\\nNav items should have one or more of: subItems, href, onClick.');\n      }\n\n      var childBadgeComponents = filterChildren(children, function (child) {\n        return hasDisplayName(child, VerticalNavBadge.displayName);\n      }) || badges && badges.length > 0 && badges.map(function (badge) {\n        var badgeKey = badge.badgeClass || badge.iconClass || badge.tooltip || badge.count;\n        return React.createElement(VerticalNavBadge, _extends({}, badge, {\n          key: badgeKey\n        }));\n      });\n      var onPinnedPath = pinnedPath && pinnedPath.startsWith(this.idPath());\n      var icon = iconClass && React.createElement('span', {\n        className: classNames(iconClass, {\n          hidden: hiddenIcons\n        }),\n        title: title\n      });\n      var item = React.createElement(ListGroupItem, {\n        listItem: true // Renders as <li>. Other props can change this, see logic in react-bootstrap's ListGroupItem.\n        ,\n        className: classNames((_classNames = {}, _defineProperty(_classNames, nextDepth + '-nav-item-pf', depth !== 'tertiary' && childItemComponents && childItemComponents.length > 0), _defineProperty(_classNames, 'active', active || pinned && pinnableMenus), _defineProperty(_classNames, 'is-hover', pinnableMenus && onPinnedPath || depth !== 'tertiary' && hovered), _defineProperty(_classNames, 'mobile-nav-item-pf', selectedOnMobile && (depth === 'primary' && showMobileSecondary || depth === 'secondary')), _defineProperty(_classNames, 'mobile-secondary-item-pf', selectedOnMobile && depth === 'primary' && showMobileTertiary), _classNames), className),\n        onMouseEnter: this.onItemHover // NOTE onItemBlur takes a boolean, we want to prevent it being passed a truthy event.\n        ,\n        onMouseLeave: function onMouseLeave(e) {\n          return _this2.onItemBlur(false);\n        }\n      }, React.createElement('a', {\n        id: id,\n        'data-id': dataID,\n        href: href || '#',\n        onClick: this.onItemClick\n      }, depth === 'primary' && icon && (!isMobile && navCollapsed ? React.createElement(OverlayTrigger, {\n        placement: 'bottom',\n        overlay: React.createElement(Tooltip, {\n          id: title\n        }, title)\n      }, icon) : icon), React.createElement('span', {\n        className: 'list-group-item-value'\n      }, title), showBadges && childBadgeComponents && React.createElement('div', {\n        className: 'badge-container-pf'\n      }, childBadgeComponents)), childItemComponents && childItemComponents.length > 0 && React.createElement('div', {\n        className: 'nav-pf-' + nextDepth + '-nav'\n      }, React.createElement('div', {\n        className: 'nav-item-pf-header'\n      }, (pinnableMenus || isMobile) && React.createElement('a', {\n        className: classNames(nextDepth + '-collapse-toggle-pf', {\n          collapsed: onPinnedPath\n        }),\n        onClick: this.pinNextDepth\n      }), React.createElement('span', null, title)), React.createElement(NavContextProvider, _extends({}, this.props, {\n        idPath: this.idPath(),\n        item: navItem\n      }), React.createElement(ListGroup, {\n        componentClass: 'ul'\n      }, childItemComponents))));\n      var divider = React.createElement(ListGroupItem, {\n        listItem: true\n      }, React.createElement(VerticalNavDividerItem, {\n        title: title\n      }));\n      return isDivider ? divider : item;\n    }\n  }]);\n\n  return BaseVerticalNavItemHelper;\n}(React.Component);\n\nBaseVerticalNavItemHelper.propTypes = _extends({}, itemObjectTypes, navContextTypes, {\n  /** Properties of the nav item, as an object. Can alternatively be passed as individual props. */\n  item: PropTypes.shape(itemObjectTypes),\n\n  /**\n   * Sub-items, passed as JSX children (SecondaryItem, TertiaryItem).\n   * Can alternatively pass subItems array as part of item or as its own prop.\n   */\n  children: PropTypes.node,\n  title: PropTypes.string,\n\n  /** Divider bool */\n  isDivider: PropTypes.bool,\n\n  /** should Prevent Href */\n  preventHref: PropTypes.bool,\n\n  /** anchor id */\n  id: PropTypes.string,\n\n  /** anchor data-id */\n  dataID: PropTypes.string\n});\nBaseVerticalNavItemHelper.defaultProps = {\n  item: {},\n  children: null,\n  title: '',\n  isDivider: false,\n  preventHref: true,\n  id: null,\n  dataID: null\n};\nvar VerticalNavItemHelper = getContext(navContextTypes)(BaseVerticalNavItemHelper);\nVerticalNavItemHelper.displayName = 'VerticalNavItemHelper';\nVerticalNavItemHelper.propTypes = _extends({}, BaseVerticalNavItemHelper.propTypes);\nexport default VerticalNavItemHelper;","map":null,"metadata":{},"sourceType":"module"}