{"ast":null,"code":"var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport { withContext } from 'recompose';\nimport { selectKeys, filterChildren } from '../../common/helpers';\nimport { VerticalNavItem, VerticalNavSecondaryItem, VerticalNavTertiaryItem } from './index'; // Properties of the nav item object, which can also be passed as\n// props directly to Item, SecondaryItem and TertiaryItem components.\n\nvar itemObjectTypes = {\n  /** Title of the nav item */\n  title: PropTypes.string,\n\n  /** Class applied to the item for icons */\n  iconClass: PropTypes.string,\n\n  /** Badges rendered on the item */\n  badges: PropTypes.arrayOf(PropTypes.shape({\n    badgeClass: PropTypes.string,\n    tooltip: PropTypes.string,\n    count: PropTypes.number,\n    iconClass: PropTypes.string\n  })),\n\n  /** Sub-items, either can be passed as objects here or as JSX children */\n  subItems: PropTypes.array,\n\n  /** Is this the current active item? (used only if tracking this in app) */\n  active: PropTypes.bool,\n\n  /** Is this the current hovered item? (used only if tracking this in app) */\n  hovered: PropTypes.bool,\n\n  /** Is this the last item we tapped on mobile? (used only if tracking this in app) */\n  selectedOnMobile: PropTypes.bool,\n\n  /** Is this item pinned? (used only if tracking this in app) */\n  pinned: PropTypes.bool,\n\n  /** Set the activePath to this item initially, but allow that state to change. */\n  initialActive: PropTypes.bool,\n\n  /** If this item is a link, what URL it should go to. */\n  href: PropTypes.string,\n\n  /** Optional callback for updating hovered prop */\n  onHover: PropTypes.func,\n\n  /** Optional callback for updating hovered prop */\n  onBlur: PropTypes.func,\n\n  /** Optional callback for updating active prop */\n  onClick: PropTypes.func,\n\n  /** Optional additional className(s) to be applied to the item */\n  className: PropTypes.string\n}; // Props that can be passed to a NavContextProvider\n\nvar navContextTypes = {\n  /** The path down the item tree so far (made up of each item's idPath() joined by '/') */\n  idPath: PropTypes.string,\n\n  /** The depth down the item tree so far. Assume 'primary' if undefined. */\n  depth: PropTypes.oneOf(['primary', 'secondary', 'tertiary']),\n\n  /** The nav item object of the ancestor at primary depth, for secondary and tertiary items. */\n  primaryItem: PropTypes.shape(itemObjectTypes),\n  // *\n\n  /** The nav item object of the ancestor at secondary depth, for tertiary items. */\n  secondaryItem: PropTypes.shape(itemObjectTypes),\n  // *\n\n  /** See VerticalNav.propTypes */\n  activePath: PropTypes.string,\n\n  /** See VerticalNav.propTypes */\n  hoverPath: PropTypes.string,\n\n  /** See VerticalNav.propTypes */\n  mobilePath: PropTypes.string,\n\n  /** See VerticalNav.propTypes */\n  pinnedPath: PropTypes.string,\n\n  /** See VerticalNav.propTypes */\n  hiddenIcons: PropTypes.bool,\n\n  /** See VerticalNav.propTypes */\n  pinnableMenus: PropTypes.bool,\n\n  /** See VerticalNav.propTypes */\n  isMobile: PropTypes.bool,\n\n  /** See VerticalNav.propTypes */\n  navCollapsed: PropTypes.bool,\n\n  /** See VerticalNav.propTypes */\n  hoverDelay: PropTypes.number,\n\n  /** See VerticalNav.propTypes */\n  blurDelay: PropTypes.number,\n\n  /** See VerticalNav.propTypes */\n  showBadges: PropTypes.bool,\n\n  /** Reference to method of the same name in the VerticalNav container. */\n  updateNavOnMenuToggleClick: PropTypes.func,\n\n  /** Reference to method of the same name in the VerticalNav container. */\n  updateNavOnItemHover: PropTypes.func,\n\n  /** Reference to method of the same name in the VerticalNav container. */\n  updateNavOnItemBlur: PropTypes.func,\n\n  /** Reference to method of the same name in the VerticalNav container. */\n  updateNavOnItemClick: PropTypes.func,\n\n  /** Reference to method of the same name in the VerticalNav container. */\n  updateNavOnPin: PropTypes.func,\n\n  /** Reference to method of the same name in the VerticalNav container. */\n  updateNavOnMobileSelection: PropTypes.func,\n\n  /** Reference to method of the same name in the VerticalNav container. */\n  setActivePath: PropTypes.func,\n\n  /** Reference to method of the same name in the VerticalNav container. */\n  setHoverPath: PropTypes.func,\n\n  /** Reference to method of the same name in the VerticalNav container. */\n  setMobilePath: PropTypes.func,\n\n  /** Reference to method of the same name in the VerticalNav container. */\n  setPinnedPath: PropTypes.func,\n\n  /** Notifies the main component that an item has used the active prop. */\n  setControlledActivePath: PropTypes.func,\n\n  /** Notifies the main component that an item has used the hovered prop. */\n  setControlledHoverPath: PropTypes.func,\n\n  /** Notifies the main component that an item has used the selectedOnMobile prop. */\n  setControlledMobilePath: PropTypes.func,\n\n  /** Notifies the main component that an item has used the selectedOnMobile prop. */\n  setControlledPinnedPath: PropTypes.func,\n\n  /** Reference to method of the same name in the VerticalNav container. */\n  forceHideSecondaryMenu: PropTypes.func,\n\n  /** (Internal helper value) */\n  showMobileSecondary: PropTypes.bool,\n\n  /** (Internal helper value) */\n  showMobileTertiary: PropTypes.bool\n};\n\nvar getNextDepth = function getNextDepth(depth) {\n  return depth === 'primary' && 'secondary' || depth === 'secondary' && 'tertiary' || 'primary';\n};\n\nvar deepestOf = function deepestOf(pri, sec, ter) {\n  return pri && sec && ter || pri && sec || pri;\n};\n\nvar componentForDepth = function componentForDepth(depth) {\n  if (depth === 'primary') return VerticalNavItem;\n  if (depth === 'secondary') return VerticalNavSecondaryItem;\n  if (depth === 'tertiary') return VerticalNavTertiaryItem;\n  return null;\n};\n\nvar wrongDepth = function wrongDepth(props, expectedDepth) {\n  if (props.depth !== expectedDepth) {\n    var componentUsed = componentForDepth(expectedDepth).displayName; // eslint-disable-next-line no-console\n\n    console.warn('Warning: ' + componentUsed + ' was used at ' + props.depth + ' depth, but it is for ' + expectedDepth + ' items.');\n  }\n};\n\nvar correctDepth = function correctDepth(props) {\n  var Component = componentForDepth(props.depth); // eslint-disable-next-line no-console\n\n  console.warn('Rendering with ' + Component.displayName + ' instead.');\n  return React.createElement(Component, props);\n};\n\ncorrectDepth.propTypes = {\n  depth: PropTypes.string\n};\ncorrectDepth.defaultProps = {\n  depth: 'primary'\n};\n\nvar isNavItem = function isNavItem(node) {\n  return node && node.type && node.type.displayName && node.type.displayName.includes('VerticalNav') && node.type.displayName.includes('Item');\n};\n\nvar getItemProps = function getItemProps(props) {\n  var itemChildren = filterChildren(props.children, isNavItem);\n  return _extends({}, selectKeys(props, Object.keys(itemObjectTypes)), {\n    subItems: itemChildren && itemChildren.map(function (child) {\n      return getItemProps(child.props);\n    })\n  });\n};\n\nvar NavContextProvider = withContext(navContextTypes, function (providerProps) {\n  // The item prop doesn't get included in context, but must be passed to the provider\n  // In order to properly include primaryItem and secondaryItem in context.\n  var item = providerProps.item,\n      primaryItem = providerProps.primaryItem,\n      secondaryItem = providerProps.secondaryItem;\n  var nextDepth = getNextDepth(providerProps.depth);\n  return _extends({}, selectKeys(providerProps, Object.keys(navContextTypes)), {\n    depth: nextDepth,\n    primaryItem: nextDepth === 'secondary' ? item : primaryItem,\n    secondaryItem: nextDepth === 'tertiary' ? item : secondaryItem // We don't need a tertiaryItem in context (see VerticalNavItem.getContextNavItems)\n\n  });\n})(function (props) {\n  return React.createElement(React.Fragment, null, props.children);\n}); // WARNING: HACK! HAAAACK HACK HACK HACK WARNING THIS IS A HACK.\n// We only use this to apply magic body classes when the prop `dynamicBodyClasses` is used.\n// And only for consistency-- the better solution is to manage these classes yourself in the application.\n\nvar getBodyContentElement = function getBodyContentElement() {\n  return document.querySelector('.container-pf-nav-pf-vertical');\n};\n\nvar setBodyClassIf = function setBodyClassIf(condition, className) {\n  var body = getBodyContentElement();\n\n  if (condition) {\n    body && body.classList.add(className);\n  } else {\n    body && body.classList.remove(className);\n  }\n};\n\nvar addBodyEventListener = function addBodyEventListener(eventName, handler) {\n  var body = getBodyContentElement();\n  body && body.addEventListener(eventName, handler);\n};\n\nvar removeBodyEventListener = function removeBodyEventListener(eventName, handler) {\n  var body = getBodyContentElement();\n  body && body.removeEventListener(eventName, handler);\n};\n\nexport { getNextDepth, deepestOf, componentForDepth, wrongDepth, correctDepth, isNavItem, getItemProps, itemObjectTypes, navContextTypes, NavContextProvider, setBodyClassIf, addBodyEventListener, removeBodyEventListener };","map":null,"metadata":{},"sourceType":"module"}