{"ast":null,"code":"var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport React from 'react';\nimport { default as Timer } from './Timer';\nimport { closest as closestPolyfill } from './closestPolyfill';\nimport { default as controlled } from './controlled';\nimport { patternfly, c3ChartDefaults, layout } from './patternfly';\n/** Equivalent to calling `this.someMethod = this.someMethod.bind(this)` for every method name in the methods array. */\n\nexport var bindMethods = function bindMethods(context, methods) {\n  // eslint-disable-next-line no-console\n  console.warn('\\n   bindMethods usage is deprecated in favor of class methods.\\n   bindMethods will be removed in the next major release\\n   ');\n  methods.forEach(function (method) {\n    context[method] = context[method].bind(context);\n  });\n};\n/** Implementation of the debounce function */\n\nexport var debounce = function debounce(func, wait) {\n  var timeout = void 0;\n\n  function innerFunc() {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var context = this;\n    clearTimeout(timeout);\n    timeout = setTimeout(function () {\n      return func.apply(context, args);\n    }, wait);\n  }\n\n  return innerFunc;\n};\n/** Returns true if propName is a non-null, defined property of the props object (can be any object, not just React props). */\n\nexport var propExists = function propExists(props, propName) {\n  return props && props.hasOwnProperty(propName) && props[propName] != null;\n};\n/** Given two objects (props and state), returns the value of propName from props if present, or from state otherwise. */\n\nexport var propOrState = function propOrState(props, state, propName) {\n  return propExists(props, propName) ? props[propName] : state[propName];\n};\n/** Returns a subset of the given object including only the given keys, with values optionally replaced by a fn. */\n\nexport var selectKeys = function selectKeys(obj, keys) {\n  var fn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (val) {\n    return val;\n  };\n  return keys.reduce(function (values, key) {\n    return _extends({}, values, _defineProperty({}, key, fn(obj[key])));\n  }, {});\n};\n/** Returns a subset of the given object with a validator function applied to its keys. */\n\nexport var filterKeys = function filterKeys(obj, validator) {\n  return selectKeys(obj, Object.keys(obj).filter(validator));\n};\n/** Returns a subset of the given object with the given keys left out. */\n\nexport var excludeKeys = function excludeKeys(obj, keys) {\n  return filterKeys(obj, function (key) {\n    return !keys.includes(key);\n  });\n};\n/** Returns the given React children prop as a regular array of React nodes. */\n\nexport var childrenToArray = function childrenToArray(children) {\n  return children && React.Children.count(children) > 0 && React.Children.toArray(children);\n};\n/** Filters the given React children prop with the given validator function. Returns an array of nodes. */\n\nexport var filterChildren = function filterChildren(children, validator) {\n  var array = childrenToArray(children);\n  return array && array.filter(validator);\n};\n/** Given a React children prop, finds the first child node to pass the validator function. */\n\nexport var findChild = function findChild(children, validator) {\n  var array = childrenToArray(children);\n  return array && array.find(validator);\n};\n/** Returns true if there is at least one of propNames with a different value in newProps than in oldProps. */\n\nexport var propsChanged = function propsChanged(propNames, oldProps, newProps) {\n  return propNames.some(function (propName) {\n    return oldProps[propName] !== newProps[propName];\n  });\n};\n/** Returns true if the component has the desired displayName value */\n\nexport var hasDisplayName = function hasDisplayName(component, displayName) {\n  return component && component.type && component.type.displayName === displayName;\n};\n/** Returns an object with the same keys as the given one, but all null values. */\n\nexport var nullValues = function nullValues(obj) {\n  return selectKeys(obj, Object.keys(obj), function () {\n    return null;\n  });\n};\nexport var noop = Function.prototype;\nexport var KEY_CODES = {\n  TAB_KEY: 9,\n  ENTER_KEY: 13,\n  ESCAPE_KEY: 27,\n  SHIFT: 16,\n  A: 65,\n  Z: 90,\n  NUMPAD: {\n    0: 97\n  },\n  F11: 122\n};\nexport var KEYS = {\n  ENTER: 'Enter',\n  CAPSLOCK: 'CapsLock',\n  SPACE: ' ',\n  ARROW_LEFT: 'ArrowLeft',\n  ARROW_RIGHT: 'ArrowRight',\n  ARROW_DOWN: 'ArrowDown',\n  ARROW_UP: 'ArrowUp',\n  HOME: 'Home',\n  END: 'End'\n};\nexport var helpers = {\n  Timer: Timer,\n  closestPolyfill: closestPolyfill,\n  controlled: controlled,\n  patternfly: patternfly,\n  c3ChartDefaults: c3ChartDefaults,\n  layout: layout,\n  debounce: debounce,\n  propExists: propExists,\n  propOrState: propOrState,\n  selectKeys: selectKeys,\n  filterKeys: filterKeys,\n  excludeKeys: excludeKeys,\n  childrenToArray: childrenToArray,\n  filterChildren: filterChildren,\n  findChild: findChild,\n  propsChanged: propsChanged,\n  hasDisplayName: hasDisplayName,\n  nullValues: nullValues,\n  noop: noop,\n  KEY_CODES: KEY_CODES,\n  KEYS: KEYS\n};\nexport default helpers;","map":null,"metadata":{},"sourceType":"module"}