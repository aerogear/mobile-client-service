{"ast":null,"code":"import _regeneratorRuntime from \"/Users/weili/work/mobile-next/golang/src/github.com/aerogear/mobile-developer-console/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/weili/work/mobile-next/golang/src/github.com/aerogear/mobile-developer-console/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { compact } from 'lodash-es';\nimport { mobileServices } from '../services/mobileservices';\nimport { list, watch, create, OpenShiftWatchEvents, remove, getNamespace } from '../services/openshift';\nimport { errorCreator } from './errors';\nexport var SERVICES_REQUEST = 'SERVICES_REQUEST';\nexport var SERVICES_SUCCESS = 'SERVICES_SUCCESS';\nexport var SERVICES_FAILURE = 'SERVICES_FAILURE';\nexport var CUSTOM_RESOURCE_LIST_SUCCESS = 'CUSTOM_RESOURCE_LIST_SUCCESS';\nexport var CUSTOM_RESOURCE_LIST_ERROR = 'CUSTOM_RESOURCE_LIST_ERROR';\nexport var CUSTOM_RESOURCE_WS_ERROR = 'CUSTOM_RESOURCE_WS_ERROR';\nexport var CUSTOM_RESOURCE_ADDED_SUCCESS = 'CUSTOM_RESOURCE_ADDED_SUCCESS';\nexport var CUSTOM_RESOURCE_MODIFIED_SUCCESS = 'CUSTOM_RESOURCE_MODIFIED_SUCCESS';\nexport var CUSTOM_RESOURCE_DELETED_SUCCESS = 'CUSTOM_RESOURCE_DELETED_SUCCESS';\nvar watchStatus = {}; // the services are unlikely to change because they should be pre-provisioned, so we can just use the data from the store if it's available already.\n\nfunction getServiceItemsFromStoreOrRemote(_x, _x2) {\n  return _getServiceItemsFromStoreOrRemote.apply(this, arguments);\n}\n\nfunction _getServiceItemsFromStoreOrRemote() {\n  _getServiceItemsFromStoreOrRemote = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee4(dispatch, getState) {\n    var currentItems, serviceItems;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            currentItems = getState().services;\n\n            if (!(currentItems && currentItems.items.length > 0)) {\n              _context4.next = 3;\n              break;\n            }\n\n            return _context4.abrupt(\"return\", currentItems.items);\n\n          case 3:\n            dispatch({\n              type: SERVICES_REQUEST\n            });\n            _context4.next = 6;\n            return mobileServices.list();\n\n          case 6:\n            serviceItems = _context4.sent;\n            dispatch({\n              type: SERVICES_SUCCESS,\n              result: serviceItems\n            });\n            return _context4.abrupt(\"return\", serviceItems);\n\n          case 9:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _getServiceItemsFromStoreOrRemote.apply(this, arguments);\n}\n\nfunction listCustomResourceForServiceIfRequired(dispatch, service) {\n  var custRes = service.bindCustomResource; // If there is already a list of custom resources available and we are still watching them, then the store is up to date and there is no need to list again\n\n  if (service.customResources && watchStatus[custRes.kind]) {\n    return Promise.resolve();\n  }\n\n  return listCustomResourceForService(dispatch, service);\n}\n\nfunction listAndWatchResourceIfRequired(dispatch, service) {\n  return listCustomResourceForServiceIfRequired(dispatch, service).then(function () {\n    return watchCustomResourceIfRequired(dispatch, service);\n  });\n}\n\nexport var fetchAndWatchServices = function fetchAndWatchServices() {\n  return (\n    /*#__PURE__*/\n    function () {\n      var _ref = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(dispatch, getState) {\n        var serviceItems, promises;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n                _context.next = 3;\n                return getServiceItemsFromStoreOrRemote(dispatch, getState);\n\n              case 3:\n                serviceItems = _context.sent;\n                promises = compact(serviceItems.items.map(function (service) {\n                  if (service.bindCustomResource) {\n                    return listAndWatchResourceIfRequired(dispatch, service);\n                  }\n\n                  return undefined;\n                }));\n                _context.next = 7;\n                return Promise.all(promises);\n\n              case 7:\n                _context.next = 13;\n                break;\n\n              case 9:\n                _context.prev = 9;\n                _context.t0 = _context[\"catch\"](0);\n                dispatch({\n                  type: SERVICES_FAILURE,\n                  error: _context.t0\n                });\n                dispatch(errorCreator(_context.t0));\n\n              case 13:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[0, 9]]);\n      }));\n\n      return function (_x3, _x4) {\n        return _ref.apply(this, arguments);\n      };\n    }()\n  );\n};\nexport var createCustomResourceForService = function createCustomResourceForService(service, formdata) {\n  return (\n    /*#__PURE__*/\n    function () {\n      var _ref2 = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(dispatch) {\n        var resDef, reqBody;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                resDef = service.customResourceDef();\n                reqBody = service.newCustomResource(formdata); // we don't need to handle success event here as it will be handled by the WS handler\n\n                return _context2.abrupt(\"return\", create(resDef, reqBody).catch(function (err) {\n                  dispatch(errorCreator(err));\n                }));\n\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      return function (_x5) {\n        return _ref2.apply(this, arguments);\n      };\n    }()\n  );\n};\nexport var deleteCustomResource = function deleteCustomResource(service, cr) {\n  return (\n    /*#__PURE__*/\n    function () {\n      var _ref3 = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3(dispatch) {\n        var resDef;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                resDef = service.customResourceDef();\n                return _context3.abrupt(\"return\", remove(resDef, cr).catch(function (err) {\n                  dispatch(errorCreator(err));\n                }));\n\n              case 2:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      return function (_x6) {\n        return _ref3.apply(this, arguments);\n      };\n    }()\n  );\n};\n\nfunction listCustomResourceForService(dispatch, service) {\n  var custRes = service.bindCustomResource;\n  custRes.namespace = getNamespace();\n  return list(custRes).then(function (resList) {\n    var items = resList.items;\n    dispatch({\n      type: CUSTOM_RESOURCE_LIST_SUCCESS,\n      service: service,\n      resource: custRes,\n      items: items\n    });\n    return items;\n  }).catch(function (error) {\n    dispatch({\n      type: CUSTOM_RESOURCE_LIST_ERROR,\n      service: service,\n      resource: custRes,\n      error: error\n    });\n    dispatch(errorCreator(error));\n    return [];\n  });\n}\n\nfunction watchCustomResourceIfRequired(dispatch, service) {\n  var custRes = service.bindCustomResource;\n\n  if (watchStatus[custRes.kind]) {\n    return Promise.resolve();\n  }\n\n  return watchCustomResource(dispatch, service);\n}\n\nfunction watchCustomResource(dispatch, service) {\n  var custRes = service.bindCustomResource;\n  custRes.namespace = getNamespace();\n  watchStatus[custRes.kind] = true; // TODO: add label selectors to the watch url\n\n  return watch(custRes).then(function (handler) {\n    handler.onEvent(function (event) {\n      if (event.type === OpenShiftWatchEvents.CLOSED) {\n        watchStatus[custRes.kind] = false;\n      } else if (event.type === OpenShiftWatchEvents.ADDED) {\n        dispatch({\n          type: CUSTOM_RESOURCE_ADDED_SUCCESS,\n          service: service,\n          resource: custRes,\n          result: event.payload\n        });\n      } else if (event.type === OpenShiftWatchEvents.MODIFIED) {\n        dispatch({\n          type: CUSTOM_RESOURCE_MODIFIED_SUCCESS,\n          service: service,\n          resource: custRes,\n          result: event.payload\n        });\n      } else if (event.type === OpenShiftWatchEvents.DELETED) {\n        dispatch({\n          type: CUSTOM_RESOURCE_DELETED_SUCCESS,\n          service: service,\n          resource: custRes,\n          result: event.payload\n        });\n      }\n    });\n    handler.catch(function (error) {\n      watchStatus[custRes.kind] = false;\n      dispatch({\n        type: CUSTOM_RESOURCE_WS_ERROR,\n        service: service,\n        resource: custRes,\n        error: error\n      });\n      dispatch(errorCreator(error));\n    });\n    return handler;\n  });\n}","map":{"version":3,"sources":["/Users/weili/work/mobile-next/golang/src/github.com/aerogear/mobile-developer-console/src/actions/services.js"],"names":["compact","mobileServices","list","watch","create","OpenShiftWatchEvents","remove","getNamespace","errorCreator","SERVICES_REQUEST","SERVICES_SUCCESS","SERVICES_FAILURE","CUSTOM_RESOURCE_LIST_SUCCESS","CUSTOM_RESOURCE_LIST_ERROR","CUSTOM_RESOURCE_WS_ERROR","CUSTOM_RESOURCE_ADDED_SUCCESS","CUSTOM_RESOURCE_MODIFIED_SUCCESS","CUSTOM_RESOURCE_DELETED_SUCCESS","watchStatus","getServiceItemsFromStoreOrRemote","dispatch","getState","currentItems","services","items","length","type","serviceItems","result","listCustomResourceForServiceIfRequired","service","custRes","bindCustomResource","customResources","kind","Promise","resolve","listCustomResourceForService","listAndWatchResourceIfRequired","then","watchCustomResourceIfRequired","fetchAndWatchServices","promises","map","undefined","all","error","createCustomResourceForService","formdata","resDef","customResourceDef","reqBody","newCustomResource","catch","err","deleteCustomResource","cr","namespace","resList","resource","watchCustomResource","handler","onEvent","event","CLOSED","ADDED","payload","MODIFIED","DELETED"],"mappings":"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","sourcesContent":["import { compact } from 'lodash-es';\nimport { mobileServices } from '../services/mobileservices';\nimport { list, watch, create, OpenShiftWatchEvents, remove, getNamespace } from '../services/openshift';\nimport { errorCreator } from './errors';\n\nexport const SERVICES_REQUEST = 'SERVICES_REQUEST';\nexport const SERVICES_SUCCESS = 'SERVICES_SUCCESS';\nexport const SERVICES_FAILURE = 'SERVICES_FAILURE';\n\nexport const CUSTOM_RESOURCE_LIST_SUCCESS = 'CUSTOM_RESOURCE_LIST_SUCCESS';\nexport const CUSTOM_RESOURCE_LIST_ERROR = 'CUSTOM_RESOURCE_LIST_ERROR';\nexport const CUSTOM_RESOURCE_WS_ERROR = 'CUSTOM_RESOURCE_WS_ERROR';\nexport const CUSTOM_RESOURCE_ADDED_SUCCESS = 'CUSTOM_RESOURCE_ADDED_SUCCESS';\nexport const CUSTOM_RESOURCE_MODIFIED_SUCCESS = 'CUSTOM_RESOURCE_MODIFIED_SUCCESS';\nexport const CUSTOM_RESOURCE_DELETED_SUCCESS = 'CUSTOM_RESOURCE_DELETED_SUCCESS';\n\nconst watchStatus = {};\n\n// the services are unlikely to change because they should be pre-provisioned, so we can just use the data from the store if it's available already.\nasync function getServiceItemsFromStoreOrRemote(dispatch, getState) {\n  const currentItems = getState().services;\n  if (currentItems && currentItems.items.length > 0) {\n    return currentItems.items;\n  }\n  dispatch({ type: SERVICES_REQUEST });\n  const serviceItems = await mobileServices.list();\n  dispatch({ type: SERVICES_SUCCESS, result: serviceItems });\n  return serviceItems;\n}\n\nfunction listCustomResourceForServiceIfRequired(dispatch, service) {\n  const custRes = service.bindCustomResource;\n  // If there is already a list of custom resources available and we are still watching them, then the store is up to date and there is no need to list again\n  if (service.customResources && watchStatus[custRes.kind]) {\n    return Promise.resolve();\n  }\n  return listCustomResourceForService(dispatch, service);\n}\n\nfunction listAndWatchResourceIfRequired(dispatch, service) {\n  return listCustomResourceForServiceIfRequired(dispatch, service).then(() =>\n    watchCustomResourceIfRequired(dispatch, service)\n  );\n}\n\nexport const fetchAndWatchServices = () => async (dispatch, getState) => {\n  try {\n    const serviceItems = await getServiceItemsFromStoreOrRemote(dispatch, getState);\n    const promises = compact(\n      serviceItems.items.map(service => {\n        if (service.bindCustomResource) {\n          return listAndWatchResourceIfRequired(dispatch, service);\n        }\n        return undefined;\n      })\n    );\n    await Promise.all(promises);\n  } catch (error) {\n    dispatch({ type: SERVICES_FAILURE, error });\n    dispatch(errorCreator(error));\n  }\n};\n\nexport const createCustomResourceForService = (service, formdata) => async dispatch => {\n  const resDef = service.customResourceDef();\n  const reqBody = service.newCustomResource(formdata);\n  // we don't need to handle success event here as it will be handled by the WS handler\n  return create(resDef, reqBody).catch(err => {\n    dispatch(errorCreator(err));\n  });\n};\n\nexport const deleteCustomResource = (service, cr) => async dispatch => {\n  const resDef = service.customResourceDef();\n  return remove(resDef, cr).catch(err => {\n    dispatch(errorCreator(err));\n  });\n};\n\nfunction listCustomResourceForService(dispatch, service) {\n  const custRes = service.bindCustomResource;\n  custRes.namespace = getNamespace();\n  return list(custRes)\n    .then(resList => {\n      const { items } = resList;\n      dispatch({ type: CUSTOM_RESOURCE_LIST_SUCCESS, service, resource: custRes, items });\n      return items;\n    })\n    .catch(error => {\n      dispatch({ type: CUSTOM_RESOURCE_LIST_ERROR, service, resource: custRes, error });\n      dispatch(errorCreator(error));\n      return [];\n    });\n}\n\nfunction watchCustomResourceIfRequired(dispatch, service) {\n  const custRes = service.bindCustomResource;\n  if (watchStatus[custRes.kind]) {\n    return Promise.resolve();\n  }\n  return watchCustomResource(dispatch, service);\n}\n\nfunction watchCustomResource(dispatch, service) {\n  const custRes = service.bindCustomResource;\n  custRes.namespace = getNamespace();\n  watchStatus[custRes.kind] = true;\n  // TODO: add label selectors to the watch url\n  return watch(custRes).then(handler => {\n    handler.onEvent(event => {\n      if (event.type === OpenShiftWatchEvents.CLOSED) {\n        watchStatus[custRes.kind] = false;\n      } else if (event.type === OpenShiftWatchEvents.ADDED) {\n        dispatch({ type: CUSTOM_RESOURCE_ADDED_SUCCESS, service, resource: custRes, result: event.payload });\n      } else if (event.type === OpenShiftWatchEvents.MODIFIED) {\n        dispatch({ type: CUSTOM_RESOURCE_MODIFIED_SUCCESS, service, resource: custRes, result: event.payload });\n      } else if (event.type === OpenShiftWatchEvents.DELETED) {\n        dispatch({ type: CUSTOM_RESOURCE_DELETED_SUCCESS, service, resource: custRes, result: event.payload });\n      }\n    });\n    handler.catch(error => {\n      watchStatus[custRes.kind] = false;\n      dispatch({ type: CUSTOM_RESOURCE_WS_ERROR, service, resource: custRes, error });\n      dispatch(errorCreator(error));\n    });\n    return handler;\n  });\n}\n"]},"metadata":{},"sourceType":"module"}