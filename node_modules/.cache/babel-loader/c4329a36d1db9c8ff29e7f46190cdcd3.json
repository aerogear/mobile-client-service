{"ast":null,"code":"var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport { ListGroup } from '../ListGroup';\nimport VerticalNavItem from './VerticalNavItem';\nimport VerticalNavMasthead from './VerticalNavMasthead';\nimport { filterChildren, findChild, hasDisplayName, noop, propsChanged } from '../../common/helpers';\nimport Timer from '../../common/Timer';\nimport controlled from '../../common/controlled';\nimport { layout } from '../../common/patternfly';\nimport { NavContextProvider, deepestOf, itemObjectTypes, addBodyEventListener, removeBodyEventListener, setBodyClassIf } from './VerticalNavConstants';\nimport VerticalNavSecondaryItem from './VerticalNavSecondaryItem';\nimport VerticalNavTertiaryItem from './VerticalNavTertiaryItem';\nimport VerticalNavBrand from './VerticalNavBrand';\nimport VerticalNavIconBar from './VerticalNavIconBar';\nimport VerticalNavBadge from './VerticalNavBadge';\nimport VerticalNavDividerItem from './VerticalNavDividerItem';\n/**\n * VerticalNav - The Vertical Navigation pattern\n * http://www.patternfly.org/pattern-library/navigation/vertical-navigation/\n */\n\nvar BaseVerticalNav = function (_React$Component) {\n  _inherits(BaseVerticalNav, _React$Component);\n\n  function BaseVerticalNav() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, BaseVerticalNav);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = BaseVerticalNav.__proto__ || Object.getPrototypeOf(BaseVerticalNav)).call.apply(_ref, [this].concat(args))), _this), _this.state = {\n      forceHidden: false,\n      // eslint-disable-line react/no-unused-state\n      controlledActivePath: false,\n      controlledHoverPath: false,\n      controlledMobilePath: false,\n      controlledPinnedPath: false\n    }, _this.onLayoutChange = function (newLayout) {\n      var _this$props = _this.props,\n          onLayoutChange = _this$props.onLayoutChange,\n          setControlledState = _this$props.setControlledState;\n      setControlledState({\n        isMobile: newLayout === 'mobile'\n      });\n      onLayoutChange && onLayoutChange(newLayout);\n    }, _this.setActivePath = function (activePath) {\n      if (!_this.state.controlledActivePath) {\n        _this.props.setControlledState({\n          activePath: activePath\n        });\n      }\n    }, _this.setControlledActivePath = function (controlledActivePath) {\n      _this.setState({\n        controlledActivePath: controlledActivePath\n      });\n    }, _this.setControlledHoverPath = function (controlledHoverPath) {\n      _this.setState({\n        controlledHoverPath: controlledHoverPath\n      });\n    }, _this.setControlledMobilePath = function (controlledMobilePath) {\n      _this.setState({\n        controlledMobilePath: controlledMobilePath\n      });\n    }, _this.setControlledPinnedPath = function (controlledPinnedPath) {\n      _this.setState({\n        controlledPinnedPath: controlledPinnedPath\n      });\n    }, _this.setHoverPath = function (hoverPath) {\n      if (!_this.state.controlledHoverPath) {\n        _this.props.setControlledState(_extends({\n          hoverPath: hoverPath\n        }, hoverPath === null ? {\n          showMobileNav: false\n        } : {}));\n      }\n    }, _this.setMobilePath = function (mobilePath) {\n      if (!_this.state.controlledMobilePath) {\n        _this.props.setControlledState({\n          mobilePath: mobilePath\n        });\n      }\n    }, _this.setPinnedPath = function (pinnedPath) {\n      if (!_this.state.controlledPinnedPath) {\n        _this.props.setControlledState({\n          pinnedPath: pinnedPath\n        });\n      }\n    }, _this.hoverTimer = new Timer(), _this.clearBodyClasses = function () {\n      if (_this.props.dynamicBodyClasses) {\n        setBodyClassIf(false, 'collapsed-nav');\n        setBodyClassIf(false, 'hidden-nav');\n      }\n    }, _this.collapseMenu = function () {\n      var _this$props2 = _this.props,\n          onCollapse = _this$props2.onCollapse,\n          setControlledState = _this$props2.setControlledState;\n      setControlledState({\n        navCollapsed: true\n      });\n      onCollapse && onCollapse();\n    }, _this.expandMenu = function () {\n      var _this$props3 = _this.props,\n          onExpand = _this$props3.onExpand,\n          setControlledState = _this$props3.setControlledState;\n      setControlledState({\n        navCollapsed: false\n      });\n      onExpand && onExpand();\n    }, _this.forceHideSecondaryMenu = function () {\n      _this.setState({\n        forceHidden: true\n      }); // eslint-disable-line react/no-unused-state\n\n\n      setTimeout(function () {\n        _this.setState({\n          forceHidden: false\n        }); // eslint-disable-line react/no-unused-state\n\n      }, 500);\n    }, _this.handleBodyClick = function () {\n      // Clear hover state on body click. Helps especially when using blurDisabled prop.\n      _this.setHoverPath(null);\n    }, _this.navigateToItem = function (item) {\n      var onNavigate = _this.props.onNavigate;\n      onNavigate(item); // Note: This should become router-aware later on.\n    }, _this.updateBodyClasses = function () {\n      // Note: Updating the body element classes from here like this is a hacky, non-react-y pattern.\n      // It's only here for consistency. See comments on getBodyContentElement in ./constants.js.\n      var _this$props4 = _this.props,\n          dynamicBodyClasses = _this$props4.dynamicBodyClasses,\n          navCollapsed = _this$props4.navCollapsed,\n          pinnedPath = _this$props4.pinnedPath,\n          isMobile = _this$props4.isMobile;\n      var collapsed = navCollapsed && pinnedPath === null;\n\n      if (dynamicBodyClasses) {\n        setBodyClassIf(!isMobile && collapsed, 'collapsed-nav');\n        setBodyClassIf(isMobile, 'hidden-nav');\n      }\n    }, _this.updateNavOnItemBlur = function (primary, secondary, tertiary, idPath, parentPath, noDelay, callback) {\n      var _this$props5 = _this.props,\n          hoverPath = _this$props5.hoverPath,\n          blurDelay = _this$props5.blurDelay,\n          blurDisabled = _this$props5.blurDisabled,\n          setControlledState = _this$props5.setControlledState;\n      var item = deepestOf(primary, secondary, tertiary);\n      var hovered = hoverPath && hoverPath.startsWith(idPath);\n\n      _this.hoverTimer.clearTimer();\n\n      if (hovered) {\n        var doBlur = function doBlur() {\n          if (!blurDisabled) {\n            // IMPORTANT: We reference this.props below for the hoverPath value when the timeout fires.\n            // If we just use the hoverPath in scope from above, it is from when the timeout was set.\n            if (idPath === _this.props.hoverPath) {\n              // Only bump up the hover path if it's still set to the item we're blurring\n              setControlledState({\n                hoverPath: parentPath\n              });\n            }\n\n            callback && callback(primary, secondary, tertiary);\n          }\n        };\n\n        if (item.subItems && item.subItems.length > 0) {\n          if (noDelay) {\n            doBlur();\n          } else {\n            _this.hoverTimer.startTimer(doBlur, blurDelay);\n          }\n        }\n      }\n    }, _this.updateNavOnItemClick = function (primary, secondary, tertiary, idPath, parentPath) {\n      var _this$props6 = _this.props,\n          onItemClick = _this$props6.onItemClick,\n          hoverPath = _this$props6.hoverPath,\n          hoverDisabled = _this$props6.hoverDisabled,\n          isMobile = _this$props6.isMobile;\n\n      _this.hoverTimer.skipTimer();\n\n      var item = deepestOf(primary, secondary, tertiary);\n      var isLeafItem = !item.subItems || item.subItems.length === 0;\n\n      if (isMobile) {\n        _this.setMobilePath(null);\n      }\n\n      if (isLeafItem) {\n        _this.setHoverPath(null);\n      } else if (hoverDisabled && hoverPath === idPath) {\n        // Clicking the currently-\"hovered\" item in hoverDisabled un-\"hovers\" it.\n        _this.setHoverPath(parentPath);\n      }\n\n      if (isLeafItem || !isMobile) {\n        _this.navigateToItem(item);\n      }\n\n      onItemClick && onItemClick(primary, secondary, tertiary);\n    }, _this.updateNavOnItemHover = function (primary, secondary, tertiary, idPath, parentPath, callback) {\n      var _this$props7 = _this.props,\n          onItemHover = _this$props7.onItemHover,\n          hoverPath = _this$props7.hoverPath,\n          hoverDelay = _this$props7.hoverDelay,\n          hoverDisabled = _this$props7.hoverDisabled,\n          isMobile = _this$props7.isMobile;\n      var item = deepestOf(primary, secondary, tertiary);\n      var hovered = hoverPath && hoverPath.startsWith(idPath);\n      var targetPath = item.subItems && item.subItems.length > 0 ? idPath : parentPath;\n      var that = _this;\n\n      if (!isMobile) {\n        _this.hoverTimer.clearTimer();\n\n        if (!hovered) {\n          _this.hoverTimer.startTimer(function (skipped) {\n            if (skipped || !hoverDisabled) {\n              that.setHoverPath(targetPath);\n              callback && callback(primary, secondary, tertiary);\n              onItemHover && onItemHover(primary, secondary, tertiary);\n            }\n          }, hoverDelay);\n        }\n      }\n    }, _this.updateNavOnMenuToggleClick = function () {\n      var _this$props8 = _this.props,\n          onMenuToggleClick = _this$props8.onMenuToggleClick,\n          isMobile = _this$props8.isMobile,\n          showMobileNav = _this$props8.showMobileNav,\n          navCollapsed = _this$props8.navCollapsed,\n          setControlledState = _this$props8.setControlledState;\n\n      if (isMobile) {\n        if (showMobileNav) {\n          setControlledState({\n            showMobileNav: false\n          });\n        } else {\n          _this.setMobilePath(null);\n\n          setControlledState({\n            showMobileNav: true\n          });\n        }\n      } else if (navCollapsed) {\n        _this.expandMenu();\n      } else {\n        _this.collapseMenu();\n      }\n\n      onMenuToggleClick && onMenuToggleClick();\n    }, _this.updateNavOnMobileSelection = function (primary, secondary, tertiary) {\n      var onMobileSelection = _this.props.onMobileSelection; // All the behavior here is handled by mobilePath and setMobilePath,\n      // but we still make a callback available here.\n\n      onMobileSelection && onMobileSelection(primary, secondary, tertiary);\n    }, _this.updateNavOnPin = function (item, depth, pinned) {\n      var _this$props9 = _this.props,\n          onItemPin = _this$props9.onItemPin,\n          isMobile = _this$props9.isMobile;\n\n      if (!isMobile) {\n        onItemPin && onItemPin(item, depth, pinned);\n      }\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  } // More state is defined in controlledStateTypes.\n  // These ones just don't need to be able to be controlled by props.\n\n\n  _createClass(BaseVerticalNav, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      this.updateBodyClasses();\n      layout.addChangeListener(this.onLayoutChange);\n      addBodyEventListener('mousedown', this.handleBodyClick);\n    }\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate(oldProps) {\n      var bodyClassProps = ['navCollapsed', 'pinnedPath', 'showMobileNav', 'isMobile'];\n\n      if (propsChanged(bodyClassProps, oldProps, this.props)) {\n        this.updateBodyClasses();\n      }\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      // Clear any timers so they don't trigger while the component is unmounted.\n      this.hoverTimer.clearTimer();\n      this.clearBodyClasses();\n      layout.removeChangeListener(this.onLayoutChange);\n      removeBodyEventListener('mousedown', this.handleBodyClick);\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _props = this.props,\n          items = _props.items,\n          children = _props.children; // Nav items may be passed either as nested VerticalNavItem children, or as nested items in a prop.\n      // The items prop will take priority, if present, and must be an array of item objects (not React components).\n      // If the items prop is not present, items must be expressed as VerticalNavItem children instead.\n\n      var itemsFromChildren = filterChildren(children, function (child) {\n        return hasDisplayName(child, VerticalNavItem.displayName);\n      });\n      var itemsFromProps = items && items.length > 0 && items.map(function (primaryItem, i) {\n        return React.createElement(VerticalNavItem, {\n          item: primaryItem,\n          key: 'primary_' + primaryItem.title\n        }, primaryItem.subItems && primaryItem.subItems.map(function (secondaryItem) {\n          return React.createElement(VerticalNavSecondaryItem, {\n            id: secondaryItem.id,\n            dataID: secondaryItem.dataID,\n            isDivider: secondaryItem.isDivider,\n            preventHref: secondaryItem.preventHref,\n            item: secondaryItem,\n            key: 'secondary_' + secondaryItem.title\n          }, secondaryItem.subItems && secondaryItem.subItems.map(function (tertiaryItem) {\n            return React.createElement(VerticalNavTertiaryItem, {\n              item: tertiaryItem,\n              key: 'tertiary_' + tertiaryItem.title\n            });\n          }));\n        }));\n      });\n      var itemComponents = itemsFromProps || itemsFromChildren || [];\n      var _props2 = this.props,\n          hiddenIcons = _props2.hiddenIcons,\n          pinnableMenus = _props2.pinnableMenus,\n          showBadges = _props2.showBadges,\n          forceHidden = _props2.forceHidden,\n          hideMasthead = _props2.hideMasthead,\n          persistentSecondary = _props2.persistentSecondary,\n          hoverDelay = _props2.hoverDelay,\n          blurDelay = _props2.blurDelay,\n          isMobile = _props2.isMobile,\n          showMobileNav = _props2.showMobileNav,\n          masthead = _props2.masthead,\n          navCollapsed = _props2.navCollapsed,\n          activePath = _props2.activePath,\n          hoverPath = _props2.hoverPath,\n          mobilePath = _props2.mobilePath,\n          pinnedPath = _props2.pinnedPath;\n      var mastheadElem = masthead || React.createElement('nav', {\n        className: classNames('navbar navbar-pf-vertical')\n      }, findChild(children, function (child) {\n        return hasDisplayName(child, VerticalNavMasthead.displayName);\n      }));\n\n      var getPathDepth = function getPathDepth(path) {\n        return path && path.split('/').filter(function (s) {\n          return s !== '';\n        }).length;\n      };\n\n      var mobileDepth = getPathDepth(mobilePath);\n      var hoverDepth = getPathDepth(hoverPath);\n      var pinnedDepth = getPathDepth(pinnedPath);\n      var showMobileSecondary = isMobile && mobileDepth >= 1;\n      var showMobileTertiary = isMobile && mobileDepth >= 2;\n      var hoverSecondaryNav = hoverDepth >= 1;\n      var hoverTertiaryNav = hoverDepth >= 2;\n      var pinnedSecondaryNav = pinnedDepth >= 1;\n      var pinnedTertiaryNav = pinnedDepth >= 2;\n      return React.createElement(NavContextProvider, {\n        idPath: '/',\n        updateNavOnMenuToggleClick: this.updateNavOnMenuToggleClick,\n        updateNavOnItemHover: this.updateNavOnItemHover,\n        updateNavOnItemBlur: this.updateNavOnItemBlur,\n        updateNavOnItemClick: this.updateNavOnItemClick,\n        updateNavOnMobileSelection: this.updateNavOnMobileSelection,\n        setActivePath: this.setActivePath,\n        setHoverPath: this.setHoverPath,\n        setMobilePath: this.setMobilePath,\n        setPinnedPath: this.setPinnedPath,\n        setControlledActivePath: this.setControlledActivePath,\n        setControlledHoverPath: this.setControlledHoverPath,\n        setControlledMobilePath: this.setControlledMobilePath,\n        setControlledPinnedPath: this.setControlledPinnedPath,\n        activePath: activePath,\n        hoverPath: hoverPath,\n        mobilePath: mobilePath,\n        pinnedPath: pinnedPath,\n        hiddenIcons: hiddenIcons,\n        pinnableMenus: pinnableMenus,\n        isMobile: isMobile,\n        showMobileSecondary: showMobileSecondary,\n        showMobileTertiary: showMobileTertiary,\n        showBadges: showBadges,\n        navCollapsed: navCollapsed,\n        updateNavOnPin: this.updateNavOnPin,\n        forceHideSecondaryMenu: this.forceHideSecondaryMenu,\n        hoverDelay: hoverDelay,\n        blurDelay: blurDelay\n      }, !hideMasthead && mastheadElem, React.createElement('div', {\n        className: classNames('nav-pf-vertical nav-pf-vertical-with-sub-menus', {\n          'nav-pf-vertical-collapsible-menus': pinnableMenus,\n          'hidden-icons-pf': hiddenIcons,\n          'nav-pf-vertical-with-badges': showBadges,\n          'nav-pf-persistent-secondary': persistentSecondary,\n          'show-mobile-secondary': showMobileSecondary,\n          'show-mobile-tertiary': showMobileTertiary,\n          'hover-secondary-nav-pf': hoverSecondaryNav,\n          'hover-tertiary-nav-pf': hoverTertiaryNav,\n          'collapsed-secondary-nav-pf': pinnableMenus && pinnedSecondaryNav,\n          'collapsed-tertiary-nav-pf': pinnableMenus && pinnedTertiaryNav,\n          hidden: isMobile,\n          collapsed: !isMobile && navCollapsed,\n          'force-hide-secondary-nav-pf': forceHidden,\n          'show-mobile-nav': showMobileNav\n        })\n      }, React.createElement(ListGroup, {\n        componentClass: 'ul'\n      }, itemComponents)));\n    }\n  }]);\n\n  return BaseVerticalNav;\n}(React.Component);\n\nvar controlledState = {\n  // NOTE: If you use any of these props, be sure to also use the corresponding callbacks/handlers.\n  // These props override values of the same name set by setControlledState().\n  types: {\n    /** Use the mobile layout of the component. Corresponds to onLayoutChange callback. */\n    isMobile: PropTypes.bool,\n\n    /** Display the nav in mobile mode */\n    showMobileNav: PropTypes.bool,\n\n    /** Collapse the nav. Corresponds to onMenuToggleClick or onCollapse and onExpand callbacks. */\n    navCollapsed: PropTypes.bool,\n\n    /** The idPath matching the currently active item. Corresponds to onItemClick callback. */\n    activePath: PropTypes.string,\n\n    /** The idPath matching the currently hovered item. Corresponds to onItemHover and onItemBlur callbacks. */\n    hoverPath: PropTypes.string,\n\n    /** The idPath matching the currently selected item on mobile. Corresponds to onMobileSelection callback. */\n    mobilePath: PropTypes.string,\n\n    /** The idPath matching the currently pinned item. Corresponds to onItemPin callback. */\n    pinnedPath: PropTypes.string\n  },\n  defaults: {\n    isMobile: layout.is('mobile'),\n    showMobileNav: null,\n    navCollapsed: null,\n    activePath: null,\n    hoverPath: null,\n    mobilePath: null,\n    pinnedPath: null\n  }\n};\nBaseVerticalNav.propTypes = _extends({}, controlledState.types, {\n  /** Navigation items, passed as an array of objects (as opposed to JSX children w/ props) */\n  items: PropTypes.arrayOf(PropTypes.shape(itemObjectTypes)),\n\n  /** Enables the pin buttons on the active submenu. */\n  pinnableMenus: PropTypes.bool,\n\n  /** Automatically applies classes to the body element when the layout changes. */\n  dynamicBodyClasses: PropTypes.bool,\n\n  /** Hide all icons */\n  hiddenIcons: PropTypes.bool,\n\n  /** Show badges in nav items */\n  showBadges: PropTypes.bool,\n\n  /** Don't show items on hover, require a click */\n  hoverDisabled: PropTypes.bool,\n\n  /** Don't hide items on blur, require a click elsewhere */\n  blurDisabled: PropTypes.bool,\n\n  /** Force the nav to be hidden temporarily. */\n  forceHidden: PropTypes.bool,\n\n  /** Hide the masthead and notification drawer areas. */\n  hideMasthead: PropTypes.bool,\n\n  /** Persist the secondary nav */\n  persistentSecondary: PropTypes.bool,\n\n  /** Delay between mouse hover and menu show in ms */\n  hoverDelay: PropTypes.number,\n\n  /** Delay between mouse blur and menu hide in ms */\n  blurDelay: PropTypes.number,\n\n  /**  */\n  masthead: PropTypes.node,\n\n  /** Optional callback for updating isMobile prop */\n  onLayoutChange: PropTypes.func,\n  // eslint-disable-line react/require-default-props\n\n  /** Optional callback for updating navCollapsed and showMobileNav props (option 1) */\n  onMenuToggleClick: PropTypes.func,\n\n  /** Optional callback for updating navCollapsed and showMobileNav props (option 2) */\n  onCollapse: PropTypes.func,\n\n  /** Optional callback for updating navCollapsed and showMobileNav props (option 2) */\n  onExpand: PropTypes.func,\n\n  /** Optional callback for updating active props on items or activePath prop. Only called on leaf item click. */\n  onNavigate: PropTypes.func,\n\n  /** Optional callback for updating active props on items or activePath prop. Called on any item click. */\n  onItemClick: PropTypes.func,\n\n  /** Optional callback for updating hovered prop on items */\n  onItemHover: PropTypes.func,\n\n  /** Optional callback for updating hovered prop on items */\n  onItemBlur: PropTypes.func,\n\n  /** Optional callback for updating pinned props on items or pinnedPath prop. */\n  onItemPin: PropTypes.func,\n\n  /** Optional callback for updating mobilePath prop */\n  onMobileSelection: PropTypes.func,\n  // *\n\n  /** Navigation items, passed as Item, SecondaryItem and TertiaryItem children. */\n  children: PropTypes.node,\n\n  /** Helper injected by `controlled()` to manage controlledStateTypes values */\n  setControlledState: PropTypes.func // eslint-disable-line react/require-default-props\n\n});\nBaseVerticalNav.defaultProps = {\n  items: null,\n  pinnableMenus: false,\n  dynamicBodyClasses: true,\n  hiddenIcons: false,\n  showBadges: false,\n  hoverDisabled: false,\n  blurDisabled: false,\n  forceHidden: false,\n  hideMasthead: false,\n  persistentSecondary: true,\n  hoverDelay: 500,\n  blurDelay: 700,\n  masthead: null,\n  onMenuToggleClick: null,\n  onCollapse: null,\n  onExpand: null,\n  onItemClick: null,\n  onItemHover: null,\n  onItemBlur: null,\n  onItemPin: null,\n  onMobileSelection: null,\n  onNavigate: noop,\n  children: null\n};\nvar NoPersist = controlled(controlledState)(BaseVerticalNav);\nvar WithPersist = controlled(_extends({}, controlledState, {\n  persist: ['navCollapsed', 'pinnedPath']\n}))(BaseVerticalNav);\n\nvar VerticalNav = function VerticalNav(_ref2) {\n  var persist = _ref2.persist,\n      props = _objectWithoutProperties(_ref2, ['persist']);\n\n  return persist ? React.createElement(WithPersist, props) : React.createElement(NoPersist, props);\n};\n\nVerticalNav.propTypes = _extends({}, BaseVerticalNav.propTypes, {\n  persist: PropTypes.bool\n});\nVerticalNav.defaultProps = _extends({}, BaseVerticalNav.defaultProps, {\n  persist: true\n});\nVerticalNav.displayName = 'VerticalNav';\nVerticalNav.NoPersist = NoPersist;\nVerticalNav.WithPersist = WithPersist;\nVerticalNav.Masthead = VerticalNavMasthead;\nVerticalNav.Item = VerticalNavItem;\nVerticalNav.SecondaryItem = VerticalNavSecondaryItem;\nVerticalNav.TertiaryItem = VerticalNavTertiaryItem;\nVerticalNav.Brand = VerticalNavBrand;\nVerticalNav.IconBar = VerticalNavIconBar;\nVerticalNav.Badge = VerticalNavBadge;\nVerticalNav.Divider = VerticalNavDividerItem;\nexport default VerticalNav;","map":null,"metadata":{},"sourceType":"module"}